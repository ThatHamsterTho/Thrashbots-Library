<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BimTi Thrashbots Controller &amp; RF library: RF24 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BimTi Thrashbots Controller &amp; RF library
   </div>
   <div id="projectbrief">Used for TrashBots as a general library for the Controller PCB &amp; RF communication.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_r_f24-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RF24 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Driver class for nRF24L01(+) 2.4GHz Wireless Transceiver.  
 <a href="class_r_f24.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bim_ti_controller___r_f24_8h_source.html">BimTiController_RF24.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary public interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >These are the main methods you need to operate the chip </p>
</div></td></tr>
<tr class="memitem:a123231bd955698373d221a84ad40055a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a123231bd955698373d221a84ad40055a">RF24</a> (uint16_t _cepin, uint16_t _cspin, uint32_t _spi_speed=RF24_SPI_SPEED)</td></tr>
<tr class="separator:a123231bd955698373d221a84ad40055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08204a6c77e9d03bd1075cf0759fccd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aa08204a6c77e9d03bd1075cf0759fccd">RF24</a> (uint32_t _spi_speed=RF24_SPI_SPEED)</td></tr>
<tr class="separator:aa08204a6c77e9d03bd1075cf0759fccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a20c73c7d9b2e02dcbae6fb9c4ba8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin</a> (void)</td></tr>
<tr class="separator:a048a20c73c7d9b2e02dcbae6fb9c4ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388fa99b0400ce0cd887f742ef53192b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a388fa99b0400ce0cd887f742ef53192b">begin</a> (_SPI *spiBus)</td></tr>
<tr class="separator:a388fa99b0400ce0cd887f742ef53192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9277681d834410ee6b38f1dda7de36e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ae9277681d834410ee6b38f1dda7de36e">begin</a> (_SPI *spiBus, uint16_t _cepin, uint16_t _cspin)</td></tr>
<tr class="separator:ae9277681d834410ee6b38f1dda7de36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59573f754a51dfe32f195435d27622a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a59573f754a51dfe32f195435d27622a8">begin</a> (uint16_t _cepin, uint16_t _cspin)</td></tr>
<tr class="separator:a59573f754a51dfe32f195435d27622a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224c55270d26dbe7b4f3492ea3056b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ac224c55270d26dbe7b4f3492ea3056b5">isChipConnected</a> ()</td></tr>
<tr class="separator:ac224c55270d26dbe7b4f3492ea3056b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening</a> (void)</td></tr>
<tr class="separator:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening</a> (void)</td></tr>
<tr class="separator:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127105eb7a3b351cfe777c1cec50627a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available</a> (void)</td></tr>
<tr class="separator:a127105eb7a3b351cfe777c1cec50627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2eacacfba96426c192066f04054c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read</a> (void *buf, uint8_t len)</td></tr>
<tr class="separator:a8e2eacacfba96426c192066f04054c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e409e62d49a23e372a70b904ae30e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a> (const uint8_t *address)</td></tr>
<tr class="separator:af2e409e62d49a23e372a70b904ae30e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc910ccc1ffcff56814b08faca5535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a> (uint8_t number, const uint8_t *address)</td></tr>
<tr class="separator:a9edc910ccc1ffcff56814b08faca5535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods provided for backwards compabibility. </p>
</div></td></tr>
<tr class="memitem:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aa7e8523f86f9f8f20c274e0c89a5fd45">openReadingPipe</a> (uint8_t number, uint64_t address)</td></tr>
<tr class="separator:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a50c8e68ee840e1860a31dbdc83afbd77">openWritingPipe</a> (uint64_t address)</td></tr>
<tr class="separator:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c2736fd0df9c8128cef408c8b88e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a30c2736fd0df9c8128cef408c8b88e92">isAckPayloadAvailable</a> (void)</td></tr>
<tr class="separator:a30c2736fd0df9c8128cef408c8b88e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a669f1c68203d5317f8f452a2bff1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a5a669f1c68203d5317f8f452a2bff1b5">beginTransaction</a> ()</td></tr>
<tr class="separator:a5a669f1c68203d5317f8f452a2bff1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b196efad61a1b8a9bf493150901edb4"><td class="memItemLeft" align="right" valign="top"><a id="a2b196efad61a1b8a9bf493150901edb4" name="a2b196efad61a1b8a9bf493150901edb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>endTransaction</b> ()</td></tr>
<tr class="separator:a2b196efad61a1b8a9bf493150901edb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Advanced Operation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpaf32cf1216e734b82e2b52429dae0bf6"></a> Methods you can use to drive the chip in more advanced ways </p>
</td></tr>
<tr class="memitem:a2e40fe66d1231a333aa2534e8491f828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a2e40fe66d1231a333aa2534e8491f828">failureDetected</a></td></tr>
<tr class="separator:a2e40fe66d1231a333aa2534e8491f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc95213ed4c8569a90eb33122e16cea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#adc95213ed4c8569a90eb33122e16cea6">printDetails</a> (void)</td></tr>
<tr class="separator:adc95213ed4c8569a90eb33122e16cea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32205b4854f595b0d32dce9c95e93ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a32205b4854f595b0d32dce9c95e93ba2">printPrettyDetails</a> (void)</td></tr>
<tr class="separator:a32205b4854f595b0d32dce9c95e93ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7dd139fabc16b77cb8325faa07620f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ace7dd139fabc16b77cb8325faa07620f">available</a> (uint8_t *pipe_num)</td></tr>
<tr class="separator:ace7dd139fabc16b77cb8325faa07620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22e44fe1a68747872fcb304a407fd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ad22e44fe1a68747872fcb304a407fd30">rxFifoFull</a> ()</td></tr>
<tr class="separator:ad22e44fe1a68747872fcb304a407fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown</a> (void)</td></tr>
<tr class="separator:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp</a> (void)</td></tr>
<tr class="separator:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a23bfe6502d74bb5bbccb3a7f2ba2b5ea">write</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b2516993481b58e724d1274a7fd9cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a47b2516993481b58e724d1274a7fd9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16d53de0327c0b41d170cbda4bf41af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ad16d53de0327c0b41d170cbda4bf41af">writeFast</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:ad16d53de0327c0b41d170cbda4bf41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking</a> (const void *buf, uint8_t len, uint32_t timeout)</td></tr>
<tr class="separator:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cc453453c94969d4d3f0edb3778c83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a> ()</td></tr>
<tr class="separator:a12cc453453c94969d4d3f0edb3778c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f54decbe9d06cb026a5d3dfb505116"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ab7f54decbe9d06cb026a5d3dfb505116">txStandBy</a> (uint32_t timeout, bool startTx=0)</td></tr>
<tr class="separator:ab7f54decbe9d06cb026a5d3dfb505116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b9fc363d3560358fe430a600a6f385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a36b9fc363d3560358fe430a600a6f385">writeAckPayload</a> (uint8_t pipe, const void *buf, uint8_t len)</td></tr>
<tr class="separator:a36b9fc363d3560358fe430a600a6f385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened</a> (bool &amp;tx_ok, bool &amp;tx_fail, bool &amp;rx_ready)</td></tr>
<tr class="separator:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd19843064cb70ec23507412e519e4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite</a> (const void *buf, uint8_t len, const bool multicast, bool startTx=1)</td></tr>
<tr class="separator:acd19843064cb70ec23507412e519e4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf25b53d28d1fcc385fd9738a531b75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:adbf25b53d28d1fcc385fd9738a531b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX</a> ()</td></tr>
<tr class="separator:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7915b1d2661a82137573344f659e81"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#adb7915b1d2661a82137573344f659e81">flush_tx</a> (void)</td></tr>
<tr class="separator:adb7915b1d2661a82137573344f659e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575c061519e7820e1850ad380c617d95"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a575c061519e7820e1850ad380c617d95">flush_rx</a> (void)</td></tr>
<tr class="separator:a575c061519e7820e1850ad380c617d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d522ccf39493510e64bf1740be790d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier</a> (void)</td></tr>
<tr class="separator:ad0d522ccf39493510e64bf1740be790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a821285f3b54553f4402eb3fd0ac6d6c1">testRPD</a> (void)</td></tr>
<tr class="separator:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5f1533b7753806c42b76e782d917e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a35e5f1533b7753806c42b76e782d917e">isValid</a> ()</td></tr>
<tr class="separator:a35e5f1533b7753806c42b76e782d917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9944d93994a80037e3586f340f5e0107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a9944d93994a80037e3586f340f5e0107">closeReadingPipe</a> (uint8_t pipe)</td></tr>
<tr class="separator:a9944d93994a80037e3586f340f5e0107"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Optional Configurators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpe1a83b99ec8153e5baf680edeeed1586"></a> Methods you can use to get or set the configuration of the chip. None are required. Calling <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a> sets up a reasonable set of defaults. </p>
</td></tr>
<tr class="memitem:a958fb99f54415101ca008ab11b3bfe79"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a958fb99f54415101ca008ab11b3bfe79">txDelay</a></td></tr>
<tr class="separator:a958fb99f54415101ca008ab11b3bfe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08121bf844f08dbe53f51576b7c4066"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ad08121bf844f08dbe53f51576b7c4066">csDelay</a></td></tr>
<tr class="separator:ad08121bf844f08dbe53f51576b7c4066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a> (uint8_t a_width)</td></tr>
<tr class="separator:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d3959c8320e64568395f4ef507aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries</a> (uint8_t delay, uint8_t count)</td></tr>
<tr class="separator:a4c6d3959c8320e64568395f4ef507aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a5e6e5a5f6c85d2638381cab2c0f3702e">setChannel</a> (uint8_t channel)</td></tr>
<tr class="separator:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a66a94609309e17edaa1919e66cea0a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a6a66a94609309e17edaa1919e66cea0a">getChannel</a> (void)</td></tr>
<tr class="separator:a6a66a94609309e17edaa1919e66cea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343e5d23477181011dea030fafb1954f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize</a> (uint8_t size)</td></tr>
<tr class="separator:a343e5d23477181011dea030fafb1954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize</a> (void)</td></tr>
<tr class="separator:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65963ed8d8fd45f847e2f673995b85e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a65963ed8d8fd45f847e2f673995b85e1">getDynamicPayloadSize</a> (void)</td></tr>
<tr class="separator:a65963ed8d8fd45f847e2f673995b85e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8efced2ee9edbcc6510878b20edc1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload</a> (void)</td></tr>
<tr class="separator:abf8efced2ee9edbcc6510878b20edc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e17eb6b56b915fd6df30a58784661f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a00e17eb6b56b915fd6df30a58784661f">disableAckPayload</a> (void)</td></tr>
<tr class="separator:a00e17eb6b56b915fd6df30a58784661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443888504975d7441d6452a09d09a8fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a443888504975d7441d6452a09d09a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486c4c47a6973614ae595ae96f221165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a486c4c47a6973614ae595ae96f221165">disableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a486c4c47a6973614ae595ae96f221165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253607ac2a1995af91a35cea6899c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck</a> ()</td></tr>
<tr class="separator:a6253607ac2a1995af91a35cea6899c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62846750b82682beb7593719eb60ed60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a62846750b82682beb7593719eb60ed60">isPVariant</a> (void)</td></tr>
<tr class="separator:a62846750b82682beb7593719eb60ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec71746d59da978bcbb975167886a2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck</a> (bool enable)</td></tr>
<tr class="separator:aec71746d59da978bcbb975167886a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dba9e558f3620ab489af68ea3dea9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a60dba9e558f3620ab489af68ea3dea9c">setAutoAck</a> (uint8_t pipe, bool enable)</td></tr>
<tr class="separator:a60dba9e558f3620ab489af68ea3dea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a711a9cc14fb459a4a1698b8665d82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ab6a711a9cc14fb459a4a1698b8665d82">setPALevel</a> (uint8_t level, bool lnaEnable=1)</td></tr>
<tr class="separator:ab6a711a9cc14fb459a4a1698b8665d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4dcd84466168c5816382ceb366067"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#af7c4dcd84466168c5816382ceb366067">getPALevel</a> (void)</td></tr>
<tr class="separator:af7c4dcd84466168c5816382ceb366067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b26abd1846e5080a0439ee372f3b8b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a54b26abd1846e5080a0439ee372f3b8b">getARC</a> (void)</td></tr>
<tr class="separator:a54b26abd1846e5080a0439ee372f3b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9920e7a95699748b003c4a839b0814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aeb9920e7a95699748b003c4a839b0814">setDataRate</a> (<a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> speed)</td></tr>
<tr class="separator:aeb9920e7a95699748b003c4a839b0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7b11dafe8ffab6135f243decce0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a72a7b11dafe8ffab6135f243decce0d7">getDataRate</a> (void)</td></tr>
<tr class="separator:a72a7b11dafe8ffab6135f243decce0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength</a> (<a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> length)</td></tr>
<tr class="separator:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ca91b829afcd94a4c11e0343e3796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#aba4ca91b829afcd94a4c11e0343e3796">getCRCLength</a> (void)</td></tr>
<tr class="separator:aba4ca91b829afcd94a4c11e0343e3796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eacd9ecfbc19864801d714c292cf8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a5eacd9ecfbc19864801d714c292cf8be">disableCRC</a> (void)</td></tr>
<tr class="separator:a5eacd9ecfbc19864801d714c292cf8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#abf68b9b0c9cd17179e9e144c3e7f9c45">maskIRQ</a> (bool tx_ok, bool tx_fail, bool rx_ready)</td></tr>
<tr class="separator:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43ad43c34337ec0de189105bab2213b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#ac43ad43c34337ec0de189105bab2213b">startConstCarrier</a> (<a class="el" href="group___p_a_level.html#ga1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a> level, uint8_t channel)</td></tr>
<tr class="separator:ac43ad43c34337ec0de189105bab2213b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa92d612b7b9b8a739a68ed7d88330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_f24.html#a38fa92d612b7b9b8a739a68ed7d88330">stopConstCarrier</a> (void)</td></tr>
<tr class="separator:a38fa92d612b7b9b8a739a68ed7d88330"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Driver class for nRF24L01(+) 2.4GHz Wireless Transceiver. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a123231bd955698373d221a84ad40055a" name="a123231bd955698373d221a84ad40055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123231bd955698373d221a84ad40055a">&#9670;&nbsp;</a></span>RF24() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cspin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>_spi_speed</em> = <code>RF24_SPI_SPEED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="class_r_f24.html" title="Driver class for nRF24L01(+) 2.4GHz Wireless Transceiver.">RF24</a> Constructor</p>
<p >Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.</p>
<p >See <a href="pages.html">Related Pages</a> for device specific information <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select (often labeled CSN) on the radio module. <br  />
<br  />
For the Arduino Due board, the <a href="https://www.arduino.cc/en/Reference/DueExtendedSPI">Arduino Due extended SPI feature</a> is not supported. This means that the Due's pins 4, 10, or 52 are not mandated options (can use any digital output pin) for the radio's CSN pin. </td></tr>
    <tr><td class="paramname">_spi_speed</td><td>The SPI speed in Hz ie: 1000000 == 1Mhz <br  />
<br  />
Users can specify default SPI speed by modifying <code>#define RF24_SPI_SPEED</code> in RF24_config.h<ul>
<li>For Arduino, the default SPI speed will only be properly configured this way on devices supporting SPI TRANSACTIONS</li>
<li>Older/Unsupported Arduino devices will use a default clock divider &amp; settings configuration</li>
<li>For Linux: The old way of setting SPI speeds using BCM2835 driver enums has been removed as of v1.3.7 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa08204a6c77e9d03bd1075cf0759fccd" name="aa08204a6c77e9d03bd1075cf0759fccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08204a6c77e9d03bd1075cf0759fccd">&#9670;&nbsp;</a></span>RF24() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>_spi_speed</em> = <code>RF24_SPI_SPEED</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A constructor for initializing the radio's hardware dynamically </p><dl class="section warning"><dt>Warning</dt><dd>You MUST use <a class="el" href="class_r_f24.html#a59573f754a51dfe32f195435d27622a8">begin(uint16_t, uint16_t)</a> or <a class="el" href="class_r_f24.html#ae9277681d834410ee6b38f1dda7de36e">begin(_SPI*, uint16_t, uint16_t)</a> to pass both the digital output pin numbers connected to the radio's CE and CSN pins. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_spi_speed</td><td>The SPI speed in Hz ie: 1000000 == 1Mhz <br  />
<br  />
Users can specify default SPI speed by modifying <code>#define RF24_SPI_SPEED</code> in RF24_config.h<ul>
<li>For Arduino, the default SPI speed will only be properly configured this way on devices supporting SPI TRANSACTIONS</li>
<li>Older/Unsupported Arduino devices will use a default clock divider &amp; settings configuration</li>
<li>For Linux: The old way of setting SPI speeds using BCM2835 driver enums has been removed as of v1.3.7 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace7dd139fabc16b77cb8325faa07620f" name="ace7dd139fabc16b77cb8325faa07620f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7dd139fabc16b77cb8325faa07620f">&#9670;&nbsp;</a></span>available() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test whether there are bytes available to be read from the FIFO buffers.</p>
<dl class="section note"><dt>Note</dt><dd>This function is named <code>available_pipe()</code> in the python wrapper. Additionally, the <code>available_pipe()</code> function (which takes no arguments) returns a 2 item tuple containing (ordered by tuple's indices):<ul>
<li>A boolean describing if there is a payload available to read from the RX FIFO buffers.</li>
<li>The pipe number that received the next available payload in the RX FIFO buffers. If the item at the tuple's index 0 is <code>False</code>, then this pipe number is invalid. </li>
</ul>
</dd>
<dd>
To use this function in python: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instatiated RF24 object</span></div>
<div class="line">has_payload, pipe_number = radio.available_pipe()  <span class="comment"># expand the tuple to 2 variables</span></div>
<div class="line"><span class="keywordflow">if</span> has_payload:</div>
<div class="line">    print(<span class="stringliteral">&quot;Received a payload with pipe&quot;</span>, pipe_number)</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pipe_num</td><td>Which pipe has the payload available <div class="fragment"><div class="line">uint8_t pipeNum;</div>
<div class="line"><span class="keywordflow">if</span>(radio.available(&amp;pipeNum)){</div>
<div class="line">  radio.read(&amp;data, <span class="keyword">sizeof</span>(data));</div>
<div class="line">  Serial.print(<span class="stringliteral">&quot;Received data on pipe &quot;</span>);</div>
<div class="line">  Serial.println(pipeNum);</div>
<div class="line">}</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>According to the datasheet, the data saved to <em>pipe_num</em> is "unreliable" during a FALLING transition on the IRQ pin. This means you should call <a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a> before calling this function during an ISR (Interrupt Service Routine).<br  />
For example: <div class="fragment"><div class="line"><span class="keywordtype">void</span> isrCallbackFunction() {</div>
<div class="line">  <span class="keywordtype">bool</span> tx_ds, tx_df, rx_dr;</div>
<div class="line">  radio.whatHappened(tx_ds, tx_df, rx_dr); <span class="comment">// resets the IRQ pin to HIGH</span></div>
<div class="line">  uint8_t pipe;                            <span class="comment">// initialize pipe data</span></div>
<div class="line">  radio.available(&amp;pipe);                  <span class="comment">// pipe data should now be reliable</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  pinMode(IRQ_PIN, INPUT);</div>
<div class="line">  attachInterrupt(digitalPinToInterrupt(IRQ_PIN), isrCallbackFunction, FALLING);</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if there is a payload available in the top (first out) level RX FIFO.</li>
<li><code>false</code> if there is nothing available in the RX FIFO because it is empty. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a127105eb7a3b351cfe777c1cec50627a" name="a127105eb7a3b351cfe777c1cec50627a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127105eb7a3b351cfe777c1cec50627a">&#9670;&nbsp;</a></span>available() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check whether there are bytes available to be read </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()){</div>
<div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#ace7dd139fabc16b77cb8325faa07620f">available(uint8_t*)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function relies on the information about the pipe number that received the next available payload. According to the datasheet, the data about the pipe number that received the next available payload is "unreliable" during a FALLING transition on the IRQ pin. This means you should call <a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a> before calling this function during an ISR (Interrupt Service Routine).<br  />
For example: <div class="fragment"><div class="line"><span class="keywordtype">void</span> isrCallbackFunction() {</div>
<div class="line">  <span class="keywordtype">bool</span> tx_ds, tx_df, rx_dr;</div>
<div class="line">  radio.whatHappened(tx_ds, tx_df, rx_dr); <span class="comment">// resets the IRQ pin to HIGH</span></div>
<div class="line">  radio.available();                       <span class="comment">// returned data should now be reliable</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  pinMode(IRQ_PIN, INPUT);</div>
<div class="line">  attachInterrupt(digitalPinToInterrupt(IRQ_PIN), isrCallbackFunction, FALLING);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a388fa99b0400ce0cd887f742ef53192b" name="a388fa99b0400ce0cd887f742ef53192b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388fa99b0400ce0cd887f742ef53192b">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::begin </td>
          <td>(</td>
          <td class="paramtype">_SPI *&#160;</td>
          <td class="paramname"><em>spiBus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a>, but allows specifying a non-default SPI bus to use. </p><dl class="section note"><dt>Note</dt><dd>This function assumes the <code>SPI::begin()</code> method was called before to calling this function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is for the Arduino platform only</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spiBus</td><td>A pointer or reference to an instantiated SPI bus object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The _SPI datatype is a "wrapped" definition that will represent various SPI implementations based on the specified platform (or SoftSPI). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Review the <a href="md_docs_arduino.html">Arduino support page</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>same result as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a> </dd></dl>

</div>
</div>
<a id="ae9277681d834410ee6b38f1dda7de36e" name="ae9277681d834410ee6b38f1dda7de36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9277681d834410ee6b38f1dda7de36e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::begin </td>
          <td>(</td>
          <td class="paramtype">_SPI *&#160;</td>
          <td class="paramname"><em>spiBus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cspin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a>, but allows dynamically specifying a SPI bus, CE pin, and CSN pin to use. </p><dl class="section note"><dt>Note</dt><dd>This function assumes the <code>SPI::begin()</code> method was called before to calling this function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is for the Arduino platform only</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spiBus</td><td>A pointer or reference to an instantiated SPI bus object. </td></tr>
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select (often labeled CSN) on the radio module. <br  />
<br  />
For the Arduino Due board, the <a href="https://www.arduino.cc/en/Reference/DueExtendedSPI">Arduino Due extended SPI feature</a> is not supported. This means that the Due's pins 4, 10, or 52 are not mandated options (can use any digital output pin) for the radio's CSN pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The _SPI datatype is a "wrapped" definition that will represent various SPI implementations based on the specified platform (or SoftSPI). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Review the <a href="md_docs_arduino.html">Arduino support page</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>same result as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a> </dd></dl>

</div>
</div>
<a id="a59573f754a51dfe32f195435d27622a8" name="a59573f754a51dfe32f195435d27622a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59573f754a51dfe32f195435d27622a8">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::begin </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_cspin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a>, but allows dynamically specifying a CE pin and CSN pin to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select (often labeled CSN) on the radio module. <br  />
<br  />
For the Arduino Due board, the <a href="https://www.arduino.cc/en/Reference/DueExtendedSPI">Arduino Due extended SPI feature</a> is not supported. This means that the Due's pins 4, 10, or 52 are not mandated options (can use any digital output pin) for the radio's CSN pin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same result as <a class="el" href="class_r_f24.html#a048a20c73c7d9b2e02dcbae6fb9c4ba8">begin()</a> </dd></dl>

</div>
</div>
<a id="a048a20c73c7d9b2e02dcbae6fb9c4ba8" name="a048a20c73c7d9b2e02dcbae6fb9c4ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a20c73c7d9b2e02dcbae6fb9c4ba8">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Begin operation of the chip</p>
<p >Call this in setup(), before calling any other methods. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!radio.begin()) {</div>
<div class="line">  Serial.println(F(<span class="stringliteral">&quot;radio hardware not responding!&quot;</span>));</div>
<div class="line">  <span class="keywordflow">while</span> (1) {} <span class="comment">// hold program in infinite loop to prevent subsequent errors</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the radio was successfully initialized</li>
<li><code>false</code> if the MCU failed to communicate with the radio hardware </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5a669f1c68203d5317f8f452a2bff1b5" name="a5a669f1c68203d5317f8f452a2bff1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a669f1c68203d5317f8f452a2bff1b5">&#9670;&nbsp;</a></span>beginTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::beginTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >For storing the result of testing the toggleFeatures() affect SPI transactions</p>
<p >Common code for SPI transactions including CSN toggle </p>

</div>
</div>
<a id="a9944d93994a80037e3586f340f5e0107" name="a9944d93994a80037e3586f340f5e0107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9944d93994a80037e3586f340f5e0107">&#9670;&nbsp;</a></span>closeReadingPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::closeReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe number to close, any integer not in range [0, 5] is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00e17eb6b56b915fd6df30a58784661f" name="a00e17eb6b56b915fd6df30a58784661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e17eb6b56b915fd6df30a58784661f">&#9670;&nbsp;</a></span>disableAckPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Disable custom payloads on the ackowledge packets</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> </dd></dl>

</div>
</div>
<a id="a5eacd9ecfbc19864801d714c292cf8be" name="a5eacd9ecfbc19864801d714c292cf8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eacd9ecfbc19864801d714c292cf8be">&#9670;&nbsp;</a></span>disableCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Disable CRC validation</p>
<dl class="section warning"><dt>Warning</dt><dd>CRC cannot be disabled if auto-ack/ESB is enabled. </dd></dl>

</div>
</div>
<a id="a486c4c47a6973614ae595ae96f221165" name="a486c4c47a6973614ae595ae96f221165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486c4c47a6973614ae595ae96f221165">&#9670;&nbsp;</a></span>disableDynamicPayloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Disable dynamically-sized payloads</p>
<p >This disables dynamic payloads on ALL pipes. Since Ack Payloads requires Dynamic Payloads, Ack Payloads are also disabled. If dynamic payloads are later re-enabled and ack payloads are desired then <a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> must be called again as well. </p>

</div>
</div>
<a id="abf8efced2ee9edbcc6510878b20edc1b" name="abf8efced2ee9edbcc6510878b20edc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8efced2ee9edbcc6510878b20edc1b">&#9670;&nbsp;</a></span>enableAckPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable custom payloads in the acknowledge packets</p>
<p >ACK payloads are a handy way to return data back to senders without manually changing the radio modes on both units.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The ACK payload feature requires the auto-ack feature to be enabled for any pipe using ACK payloads. This function does not automatically enable the auto-ack feature on pipe 0 since the auto-ack feature is enabled for all pipes by default.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>ACK payloads are dynamic payloads. This function automatically enables dynamic payloads on pipe 0 by default. Call <a class="el" href="class_r_f24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a> to enable on all pipes (especially for RX nodes that use pipes other than pipe 0 to receive transmissions expecting responses with ACK payloads). </dd></dl>

</div>
</div>
<a id="a6253607ac2a1995af91a35cea6899c31" name="a6253607ac2a1995af91a35cea6899c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6253607ac2a1995af91a35cea6899c31">&#9670;&nbsp;</a></span>enableDynamicAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicAck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable dynamic ACKs (single write multicast or unicast) for chosen messages.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called once before using the multicast parameter for any functions that offer it. To use multicast behavior about all outgoing payloads (using pipe 0) or incoming payloads (concerning all RX pipes), use <a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> for all pipes </dd>
<dd>
<a class="el" href="class_r_f24.html#a60dba9e558f3620ab489af68ea3dea9c">setAutoAck(uint8_t, bool)</a> for individual pipes</dd></dl>
<div class="fragment"><div class="line">radio.write(&amp;data, 32, 1); <span class="comment">// Sends a payload with no acknowledgement requested</span></div>
<div class="line">radio.write(&amp;data, 32, 0); <span class="comment">// Sends a payload using auto-retry/autoACK</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a443888504975d7441d6452a09d09a8fa" name="a443888504975d7441d6452a09d09a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443888504975d7441d6452a09d09a8fa">&#9670;&nbsp;</a></span>enableDynamicPayloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable dynamically-sized payloads</p>
<p >This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on ALL pipes. </p>

</div>
</div>
<a id="a575c061519e7820e1850ad380c617d95" name="a575c061519e7820e1850ad380c617d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575c061519e7820e1850ad380c617d95">&#9670;&nbsp;</a></span>flush_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_rx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty all 3 of the RX (receive) FIFO buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a id="adb7915b1d2661a82137573344f659e81" name="adb7915b1d2661a82137573344f659e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7915b1d2661a82137573344f659e81">&#9670;&nbsp;</a></span>flush_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_tx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty all 3 of the TX (transmit) FIFO buffers. This is automatically called by <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> if ACK payloads are enabled. However, <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a> does not call this function.</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a id="a54b26abd1846e5080a0439ee372f3b8b" name="a54b26abd1846e5080a0439ee372f3b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b26abd1846e5080a0439ee372f3b8b">&#9670;&nbsp;</a></span>getARC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getARC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns automatic retransmission count (ARC_CNT)</p>
<p >Value resets with each new transmission. Allows roughly estimating signal strength.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns values from 0 to 15. </dd></dl>

</div>
</div>
<a id="a6a66a94609309e17edaa1919e66cea0a" name="a6a66a94609309e17edaa1919e66cea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a66a94609309e17edaa1919e66cea0a">&#9670;&nbsp;</a></span>getChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get RF communication channel</p>
<dl class="section note"><dt>Note</dt><dd>In the python wrapper, this function is the getter of the <code>channel</code> attribute.<br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">chn = radio.channel  <span class="comment"># get the channel</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The currently configured RF Channel </dd></dl>

</div>
</div>
<a id="aba4ca91b829afcd94a4c11e0343e3796" name="aba4ca91b829afcd94a4c11e0343e3796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ca91b829afcd94a4c11e0343e3796">&#9670;&nbsp;</a></span>getCRCLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> RF24::getCRCLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the <a class="el" href="group___c_r_c_length.html">CRC length</a> (in bits) <br  />
CRC checking cannot be disabled if auto-ack is enabled </p><dl class="section return"><dt>Returns</dt><dd>One of the values defined by <a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>.<br  />
 See table in <a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a> or <a class="el" href="class_r_f24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength()</a> </dd></dl>

</div>
</div>
<a id="a72a7b11dafe8ffab6135f243decce0d7" name="a72a7b11dafe8ffab6135f243decce0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a7b11dafe8ffab6135f243decce0d7">&#9670;&nbsp;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> RF24::getDataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the currently configured transmission <a class="el" href="group___datarate.html">datarate</a></p>
<dl class="section return"><dt>Returns</dt><dd>One of the values defined by <a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>.<br  />
 See table in <a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a> or <a class="el" href="class_r_f24.html#aeb9920e7a95699748b003c4a839b0814">setDataRate()</a> </dd></dl>

</div>
</div>
<a id="a65963ed8d8fd45f847e2f673995b85e1" name="a65963ed8d8fd45f847e2f673995b85e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65963ed8d8fd45f847e2f673995b85e1">&#9670;&nbsp;</a></span>getDynamicPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getDynamicPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get Dynamic Payload Size</p>
<p >For dynamic payloads, this pulls the size of the payload off the chip</p>
<dl class="section note"><dt>Note</dt><dd>Corrupt packets are now detected and flushed per the manufacturer. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()){</div>
<div class="line">  <span class="keywordflow">if</span>(radio.getDynamicPayloadSize() &lt; 1){</div>
<div class="line">    <span class="comment">// Corrupt payload has been flushed</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  radio.read(&amp;data,<span class="keyword">sizeof</span>(data));</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Payload length of last-received dynamic payload </dd></dl>

</div>
</div>
<a id="af7c4dcd84466168c5816382ceb366067" name="af7c4dcd84466168c5816382ceb366067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4dcd84466168c5816382ceb366067">&#9670;&nbsp;</a></span>getPALevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPALevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the current <a class="el" href="group___p_a_level.html">Power Amplifier level</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>One of the values defined by <a class="el" href="group___p_a_level.html#ga1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a>.<br  />
 See tables in <a class="el" href="group___p_a_level.html#ga1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a> or <a class="el" href="class_r_f24.html#ab6a711a9cc14fb459a4a1698b8665d82">setPALevel()</a> </dd></dl>

</div>
</div>
<a id="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1" name="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">&#9670;&nbsp;</a></span>getPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get Static Payload Size</p>
<dl class="section note"><dt>Note</dt><dd>In the python wrapper, this function is the getter of the <code>payloadSize</code> attribute.<br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">pl_size = radio.payloadSize  <span class="comment"># get the static payload size</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the payload </dd></dl>

</div>
</div>
<a id="a30c2736fd0df9c8128cef408c8b88e92" name="a30c2736fd0df9c8128cef408c8b88e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c2736fd0df9c8128cef408c8b88e92">&#9670;&nbsp;</a></span>isAckPayloadAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isAckPayloadAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine if an ack payload was received in the most recent call to <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. The regular <a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> can also be used.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Call <a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to retrieve the ack payload.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if an ack payload is available. </dd></dl>

</div>
</div>
<a id="ac224c55270d26dbe7b4f3492ea3056b5" name="ac224c55270d26dbe7b4f3492ea3056b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac224c55270d26dbe7b4f3492ea3056b5">&#9670;&nbsp;</a></span>isChipConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isChipConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the chip is connected to the SPI bus </p>

</div>
</div>
<a id="a62846750b82682beb7593719eb60ed60" name="a62846750b82682beb7593719eb60ed60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62846750b82682beb7593719eb60ed60">&#9670;&nbsp;</a></span>isPVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isPVariant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine whether the hardware is an nRF24L01+ or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the hardware is nRF24L01+ (or compatible) and false if its not. </dd></dl>

</div>
</div>
<a id="a35e5f1533b7753806c42b76e782d917e" name="a35e5f1533b7753806c42b76e782d917e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e5f1533b7753806c42b76e782d917e">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test whether this is a real radio, or a mock shim for debugging. Setting either pin to 0xff is the way to indicate that this is not a real radio.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a legitimate radio </dd></dl>

</div>
</div>
<a id="abf68b9b0c9cd17179e9e144c3e7f9c45" name="abf68b9b0c9cd17179e9e144c3e7f9c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf68b9b0c9cd17179e9e144c3e7f9c45">&#9670;&nbsp;</a></span>maskIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::maskIRQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to configure what events will trigger the Interrupt Request (IRQ) pin active LOW. The following events can be configured:</p><ol type="1">
<li>"data sent": This does not mean that the data transmitted was recieved, only that the attempt to send it was complete.</li>
<li>"data failed": This means the data being sent was not recieved. This event is only triggered when the auto-ack feature is enabled.</li>
<li>"data received": This means that data from a receiving payload has been loaded into the RX FIFO buffers. Remember that there are only 3 levels available in the RX FIFO buffers.</li>
</ol>
<p >By default, all events are configured to trigger the IRQ pin active LOW. When the IRQ pin is active, use <a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a> to determine what events triggered it. Remeber that calling <a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a> also clears these events' status, and the IRQ pin will then be reset to inactive HIGH.</p>
<p >The following code configures the IRQ pin to only reflect the "data received" event: </p><div class="fragment"><div class="line">radio.maskIRQ(1, 1, 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_ok</td><td><code>true</code> ignores the "data sent" event, <code>false</code> reflects the "data sent" event on the IRQ pin. </td></tr>
    <tr><td class="paramname">tx_fail</td><td><code>true</code> ignores the "data failed" event, <code>false</code> reflects the "data failed" event on the IRQ pin. </td></tr>
    <tr><td class="paramname">rx_ready</td><td><code>true</code> ignores the "data received" event, <code>false</code> reflects the "data received" event on the IRQ pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edc910ccc1ffcff56814b08faca5535" name="a9edc910ccc1ffcff56814b08faca5535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edc910ccc1ffcff56814b08faca5535">&#9670;&nbsp;</a></span>openReadingPipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a pipe for reading</p>
<p >Up to 6 pipes can be open for reading at once. Open all the required reading pipes, and then call <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pipes 0 and 1 will store a full 5-byte address. Pipes 2-5 will technically only store a single byte, borrowing up to 4 additional bytes from pipe 1 per the assigned address width.<br  />
 Pipes 1-5 should share the same address, except the first byte. Only the first byte in the array should be unique, e.g. <div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;Prime&quot;</span>, <span class="stringliteral">&quot;2Node&quot;</span>, <span class="stringliteral">&quot;3xxxx&quot;</span>, <span class="stringliteral">&quot;4xxxx&quot;</span>};</div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(0, addresses[0]); <span class="comment">// address used is &quot;Prime&quot;</span></div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1, addresses[1]); <span class="comment">// address used is &quot;2Node&quot;</span></div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2, addresses[2]); <span class="comment">// address used is &quot;3Node&quot;</span></div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(3, addresses[3]); <span class="comment">// address used is &quot;4Node&quot;</span></div>
<div class="ttc" id="aclass_r_f24_html_a9edc910ccc1ffcff56814b08faca5535"><div class="ttname"><a href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">RF24::openReadingPipe</a></div><div class="ttdeci">void openReadingPipe(uint8_t number, const uint8_t *address)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1432</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the reading pipe 0 is opened by this function, the address passed to this function (for pipe 0) will be restored at every call to <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, but the address for pipe 0 is ONLY restored if the LSB is a non-zero value.<br  />
 Read <a href="http://maniacalbits.blogspot.com/2013/04/rf24-addressing-nrf24l01-radios-require.html">http://maniacalbits.blogspot.com/2013/04/rf24-addressing-nrf24l01-radios-require.html</a> to understand how to avoid using malformed addresses. This address restoration is implemented because of the underlying neccessary functionality of <a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe to open. Only pipe numbers 0-5 are available, an address assigned to any pipe number not in that range will be ignored. </td></tr>
    <tr><td class="paramname">address</td><td>The 24, 32 or 40 bit address of the pipe to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>There is no address length parameter because this function will always write the number of bytes (for pipes 0 and 1) that the radio addresses are configured to use (set with <a class="el" href="class_r_f24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth()</a>). </dd></dl>

</div>
</div>
<a id="aa7e8523f86f9f8f20c274e0c89a5fd45" name="aa7e8523f86f9f8f20c274e0c89a5fd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e8523f86f9f8f20c274e0c89a5fd45">&#9670;&nbsp;</a></span>openReadingPipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a pipe for reading </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>For compatibility with old code only, see newer function <a class="el" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the first 32 bits. Only the least significant byte should be unique, e.g. <div class="fragment"><div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1, 0xF0F0F0F0AA);</div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2, 0xF0F0F0F066);</div>
</div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe so should typically be avoided as a reading pipe.<br  />
 If used, the reading pipe 0 address needs to be restored at avery call to <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, and the address<br  />
 is ONLY restored if the LSB is a non-zero value.<br  />
 See <a href="http://maniacalbits.blogspot.com/2013/04/rf24-addressing-nrf24l01-radios-require.html">http://maniacalbits.blogspot.com/2013/04/rf24-addressing-nrf24l01-radios-require.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2e409e62d49a23e372a70b904ae30e1" name="af2e409e62d49a23e372a70b904ae30e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e409e62d49a23e372a70b904ae30e1">&#9670;&nbsp;</a></span>openWritingPipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >New: Open a pipe for writing via byte array. Old addressing format retained for compatibility.</p>
<p >Only one writing pipe can be opened at once, but this function changes the address that is used to transmit (ACK payloads/packets do not apply here). Be sure to call <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> prior to calling this function.</p>
<p >Addresses are assigned via a byte array, default is 5 byte address length</p>
<div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;1Node&quot;</span>, <span class="stringliteral">&quot;2Node&quot;</span>};</div>
<div class="line">radio.openWritingPipe(addresses[0]);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">uint8_t address[] = { 0xCC, 0xCE, 0xCC, 0xCE, 0xCC };</div>
<div class="line">radio.openWritingPipe(address);</div>
<div class="line">address[0] = 0x33;</div>
<div class="line">radio.openReadingPipe(1, address);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This function will overwrite the address set to reading pipe 0 as stipulated by the datasheet for proper auto-ack functionality in TX mode. Use this function to ensure proper transmission acknowledgement when the address set to reading pipe 0 (via <a class="el" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a>) does not match the address passed to this function. If the auto-ack feature is disabled, then this function will still overwrite the address for reading pipe 0 regardless.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to be used for outgoing transmissions (uses pipe 0). Coordinate this address amongst other receiving nodes (the pipe numbers don't need to match).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>There is no address length parameter because this function will always write the number of bytes that the radio addresses are configured to use (set with <a class="el" href="class_r_f24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth()</a>). </dd></dl>

</div>
</div>
<a id="a50c8e68ee840e1860a31dbdc83afbd77" name="a50c8e68ee840e1860a31dbdc83afbd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c8e68ee840e1860a31dbdc83afbd77">&#9670;&nbsp;</a></span>openWritingPipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a pipe for writing </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>For compatibility with old code only, see newer function <a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a></dd></dl>
<p >Addresses are 40-bit hex values, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a>(0xF0F0F0F0F0);</div>
<div class="ttc" id="aclass_r_f24_html_af2e409e62d49a23e372a70b904ae30e1"><div class="ttname"><a href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">RF24::openWritingPipe</a></div><div class="ttdeci">void openWritingPipe(const uint8_t *address)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1380</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a51923a09ba4f3478aba9be0f8a6a1" name="aa0a51923a09ba4f3478aba9be0f8a6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a51923a09ba4f3478aba9be0f8a6a1">&#9670;&nbsp;</a></span>powerDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enter low-power mode</p>
<p >To return to normal power mode, call <a class="el" href="class_r_f24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, a basic radio will consume about 13.5mA at max PA level. During active transmission, the radio will consume about 11.5mA, but this will be reduced to 26uA (.026mA) between sending. In full powerDown mode, the radio will consume approximately 900nA (.0009mA)</dd></dl>
<div class="fragment"><div class="line">radio.powerDown();</div>
<div class="line">avr_enter_sleep_mode(); <span class="comment">// Custom function to sleep the device</span></div>
<div class="line">radio.powerUp();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5cdaf47aa0edd6dca1b9a8bb7972a1a3" name="a5cdaf47aa0edd6dca1b9a8bb7972a1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">&#9670;&nbsp;</a></span>powerUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Leave low-power mode - required for normal radio operation after calling <a class="el" href="class_r_f24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a></p>
<p >To return to low power mode, call <a class="el" href="class_r_f24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a>. </p><dl class="section note"><dt>Note</dt><dd>This will take up to 5ms for maximum compatibility </dd></dl>

</div>
</div>
<a id="adc95213ed4c8569a90eb33122e16cea6" name="adc95213ed4c8569a90eb33122e16cea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc95213ed4c8569a90eb33122e16cea6">&#9670;&nbsp;</a></span>printDetails()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::printDetails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print a giant block of debugging information to stdout</p>
<dl class="section warning"><dt>Warning</dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h The printf.h file is included with the library for Arduino. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;printf.h&gt;</span></div>
<div class="line">setup(){</div>
<div class="line"> Serial.begin(115200);</div>
<div class="line"> printf_begin();</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a32205b4854f595b0d32dce9c95e93ba2" name="a32205b4854f595b0d32dce9c95e93ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32205b4854f595b0d32dce9c95e93ba2">&#9670;&nbsp;</a></span>printPrettyDetails()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::printPrettyDetails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print a giant block of debugging information to stdout. This function differs from <a class="el" href="class_r_f24.html#adc95213ed4c8569a90eb33122e16cea6">printDetails()</a> because it makes the information more understandable without having to look up the datasheet or convert hexadecimal to binary. Only use this function if your application can spare extra bytes of memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h The printf.h file is included with the library for Arduino. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;printf.h&gt;</span></div>
<div class="line">setup(){</div>
<div class="line"> Serial.begin(115200);</div>
<div class="line"> printf_begin();</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the automatic acknowledgements feature is configured differently for each pipe, then a binary representation is used in which bits 0-5 represent pipes 0-5 respectively. A <code>0</code> means the feature is disabled and a <code>1</code> means the feature is enabled. </dd></dl>

</div>
</div>
<a id="a8e2eacacfba96426c192066f04054c5b" name="a8e2eacacfba96426c192066f04054c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2eacacfba96426c192066f04054c5b">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read payload data from the RX FIFO buffer(s).</p>
<p >The length of data read is usually the next available payload's length </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a65963ed8d8fd45f847e2f673995b85e1">getDynamicPayloadSize()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>I specifically chose <code>void*</code> as a data type to make it easier for beginners to use. No casting needed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a buffer where the data should be written </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read into the buffer. This value should match the length of the object referenced using the <code>buf</code> parameter. The absolute maximum number of bytes that can be read in one call is 32 (for dynamic payload lengths) or whatever number was previously passed to <a class="el" href="class_r_f24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a> (for static payload lengths). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Remember that each call to <a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> fetches data from the RX FIFO beginning with the first byte from the first available payload. A payload is not removed from the RX FIFO until it's entire length (or more) is fetched using <a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read()</a>. </dd>
<dd>
<ul>
<li>If <em>len</em> parameter's value is less than the available payload's length, then the payload remains in the RX FIFO.</li>
<li>If <em>len</em> parameter's value is greater than the first of multiple available payloads, then the data saved to the <em>buf</em> parameter's object will be supplemented with data from the next available payload.</li>
<li>If <em>len</em> parameter's value is greater than the last available payload's length, then the last byte in the payload is used as padding for the data saved to the <em>buf</em> parameter's object. The nRF24L01 will repeatedly use the last byte from the last payload even when <a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> is called with an empty RX FIFO.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To use this function in the python wrapper, remember that only the <em>len</em> parameter is required because this function (in the python wrapper) returns the payload data as a buffer protocol object (bytearray object). <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line"><span class="keywordflow">if</span> radio.available():</div>
<div class="line">    length = radio.getDynamicPayloadSize()  <span class="comment"># or radio.getPayloadSize() for static payload sizes</span></div>
<div class="line">    received_payload = radio.read(length)</div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>No return value. Use <a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function no longer returns a boolean. Use available to determine if packets are available. The <code>RX_DR</code> Interrupt flag is now cleared with this function instead of when calling <a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>. <div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.available()) {</div>
<div class="line">  radio.read(&amp;data, <span class="keyword">sizeof</span>(data));</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeaf7fa54d3ab2a85ce215b4bf6ae933b" name="aeaf7fa54d3ab2a85ce215b4bf6ae933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf7fa54d3ab2a85ce215b4bf6ae933b">&#9670;&nbsp;</a></span>reUseTX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::reUseTX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The function will instruct the radio to re-use the payload in the top level (first out) of the TX FIFO buffers. This is used internally by <a class="el" href="class_r_f24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a> to initiate retries when a TX failure occurs. Retries are automatically initiated except with the standard <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. This way, data is not flushed from the buffer until calling <a class="el" href="class_r_f24.html#adb7915b1d2661a82137573344f659e81">flush_tx()</a>. If the TX FIFO has only the one payload (in the top level), the re-used payload can be overwritten by using <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>, <a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a>, <a class="el" href="class_r_f24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a>, <a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite()</a>, or <a class="el" href="class_r_f24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite()</a>. If the TX FIFO has other payloads enqueued, then the aforementioned functions will attempt to enqueue the a new payload in the TX FIFO (does not overwrite the top level of the TX FIFO). Currently, <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> also calls <a class="el" href="class_r_f24.html#adb7915b1d2661a82137573344f659e81">flush_tx()</a> when ACK payloads are enabled (via <a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a>).</p>
<p >Upon exiting, this function will set the CE pin HIGH to initiate the re-transmission process. If only 1 re-transmission is desired, then the CE pin should be set to LOW after the mandatory minumum pulse duration of 10 microseconds.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function only applies when taking advantage of the auto-retry feature. See <a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> and <a class="el" href="class_r_f24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries()</a> to configure the auto-retry feature.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is to be used AFTER auto-retry fails if wanting to resend using the built-in payload reuse feature. After issuing <a class="el" href="class_r_f24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX()</a>, it will keep resending the same payload until a transmission failure occurs or the CE pin is set to LOW (whichever comes first). In the event of a re-transmission failure, simply call this function again to resume re-transmission of the same payload. </dd></dl>

</div>
</div>
<a id="ad22e44fe1a68747872fcb304a407fd30" name="ad22e44fe1a68747872fcb304a407fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22e44fe1a68747872fcb304a407fd30">&#9670;&nbsp;</a></span>rxFifoFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::rxFifoFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use this function to check if the radio's RX FIFO levels are all occupied. This can be used to prevent data loss because any incoming transmissions are rejected if there is no unoccupied levels in the RX FIFO to store the incoming payload. Remember that each level can hold up to a maximum of 32 bytes. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if all three 3 levels of the RX FIFO buffers are occupied.</li>
<li><code>false</code> if there is one or more levels available in the RX FIFO buffers. Remember that this does not always mean that the RX FIFO buffers are empty; use <a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> to see if the RX FIFO buffers are empty or not. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad5aea7f9a3bd9c7d357fb296ce751f21" name="ad5aea7f9a3bd9c7d357fb296ce751f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aea7f9a3bd9c7d357fb296ce751f21">&#9670;&nbsp;</a></span>setAddressWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAddressWidth </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the address width from 3 to 5 bytes (24, 32 or 40 bit)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_width</td><td>The address width (in bytes) to use; this can be 3, 4 or 5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec71746d59da978bcbb975167886a2cc" name="aec71746d59da978bcbb975167886a2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec71746d59da978bcbb975167886a2cc">&#9670;&nbsp;</a></span>setAutoAck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable or disable the auto-acknowledgement feature for all pipes. This feature is enabled by default. Auto-acknowledgement responds to every recieved payload with an empty ACK packet. These ACK packets get sent from the receiving radio back to the transmitting radio. To attach an ACK payload to a ACK packet, use <a class="el" href="class_r_f24.html#a36b9fc363d3560358fe430a600a6f385">writeAckPayload()</a>.</p>
<p >If this feature is disabled on a transmitting radio, then the transmitting radio will always report that the payload was recieved (even if it was not). Please remember that this feature's configuration needs to match for transmitting and receiving radios.</p>
<dl class="section warning"><dt>Warning</dt><dd>When using the <code>multicast</code> parameter to <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>, this feature can be disabled for an individual payload. However, if this feature is disabled, then the <code>multicast</code> parameter will have no effect.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If disabling auto-acknowledgment packets, the ACK payloads feature is also disabled as this feature is required to send ACK payloads.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a36b9fc363d3560358fe430a600a6f385">writeAckPayload()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) the auto-acknowledgment feature for all pipes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60dba9e558f3620ab489af68ea3dea9c" name="a60dba9e558f3620ab489af68ea3dea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dba9e558f3620ab489af68ea3dea9c">&#9670;&nbsp;</a></span>setAutoAck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable or disable the auto-acknowledgement feature for a specific pipe. This feature is enabled by default for all pipes. Auto-acknowledgement responds to every recieved payload with an empty ACK packet. These ACK packets get sent from the receiving radio back to the transmitting radio. To attach an ACK payload to a ACK packet, use <a class="el" href="class_r_f24.html#a36b9fc363d3560358fe430a600a6f385">writeAckPayload()</a>.</p>
<p >Pipe 0 is used for TX operations, which include sending ACK packets. If using this feature on both TX &amp; RX nodes, then pipe 0 must have this feature enabled for the RX &amp; TX operations. If this feature is disabled on a transmitting radio's pipe 0, then the transmitting radio will always report that the payload was recieved (even if it was not). Remember to also enable this feature for any pipe that is openly listening to a transmitting radio with this feature enabled.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this feature is enabled for pipe 0, then the <code>multicast</code> parameter to <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> can be used to disable this feature for an individual payload. However, if this feature is disabled for pipe 0, then the <code>multicast</code> parameter will have no effect.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If disabling auto-acknowledgment packets on pipe 0, the ACK payloads feature is also disabled as this feature is required on pipe 0 to send ACK payloads.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a36b9fc363d3560358fe430a600a6f385">writeAckPayload()</a> </dd>
<dd>
enableAckPayloads() </dd>
<dd>
disableAckPayloads()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe to configure. This number should be in range [0, 5]. </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) the auto-acknowledgment feature for the specified pipe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e6e5a5f6c85d2638381cab2c0f3702e" name="a5e6e5a5f6c85d2638381cab2c0f3702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e5a5f6c85d2638381cab2c0f3702e">&#9670;&nbsp;</a></span>setChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set RF communication channel. The frequency used by a channel is calculated as: </p><pre class="fragment">2400 MHz + &lt;channel number&gt; </pre><p> Meaning the default channel of 76 uses the approximate frequency of 2476 MHz.</p>
<dl class="section note"><dt>Note</dt><dd>In the python wrapper, this function is the setter of the <code>channel</code> attribute.<br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">radio.channel = 2  <span class="comment"># set the channel to 2 (2402 MHz)</span></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Which RF channel to communicate on, 0-125 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f626fc4a58dd997153bcc0f8198b9e" name="a89f626fc4a58dd997153bcc0f8198b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f626fc4a58dd997153bcc0f8198b9e">&#9670;&nbsp;</a></span>setCRCLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setCRCLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the <a class="el" href="group___c_r_c_length.html">CRC length</a> (in bits) <br  />
CRC cannot be disabled if auto-ack is enabled </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Specify one of the values (as defined by <a class="el" href="group___c_r_c_length.html#gadbe00719f3f835c82bd007081d040a7e">rf24_crclength_e</a>) <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>length</code> (enum value)   </th><th class="markdownTableHeadCenter">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___c_r_c_length.html#ggadbe00719f3f835c82bd007081d040a7ea77871b6e6fac61d79be7edf1a60b9cbf">RF24_CRC_DISABLED</a> (0)   </td><td class="markdownTableBodyCenter">to disable using CRC checksums    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group___c_r_c_length.html#ggadbe00719f3f835c82bd007081d040a7eade0b6b3a0dd8729e2a17c49896e0a468">RF24_CRC_8</a> (1)   </td><td class="markdownTableBodyCenter">to use 8-bit checksums    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___c_r_c_length.html#ggadbe00719f3f835c82bd007081d040a7ea6eeb0379e23be63559106d96ada47a56">RF24_CRC_16</a> (2)   </td><td class="markdownTableBodyCenter">to use 16-bit checksums   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb9920e7a95699748b003c4a839b0814" name="aeb9920e7a95699748b003c4a839b0814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9920e7a95699748b003c4a839b0814">&#9670;&nbsp;</a></span>setDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the transmission <a class="el" href="group___datarate.html">datarate</a></p>
<dl class="section warning"><dt>Warning</dt><dd>setting <a class="el" href="group___datarate.html#gga82745de4aa1251b7561564b3ed1d6522ad6a241689903e120c99b6963cb98c97c">RF24_250KBPS</a> will fail for non-plus modules (when <a class="el" href="class_r_f24.html#a62846750b82682beb7593719eb60ed60">isPVariant()</a> returns false).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>Specify one of the following values (as defined by <a class="el" href="group___datarate.html#ga82745de4aa1251b7561564b3ed1d6522">rf24_datarate_e</a>): <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>speed</code> (enum value)   </th><th class="markdownTableHeadCenter">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___datarate.html#gga82745de4aa1251b7561564b3ed1d6522afd01f3fd55247a67c0bcfd459fe17fdf">RF24_1MBPS</a> (0)   </td><td class="markdownTableBodyCenter">for 1 Mbps    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group___datarate.html#gga82745de4aa1251b7561564b3ed1d6522a53050a70cedbbf10620ba0fe2b043f1b">RF24_2MBPS</a> (1)   </td><td class="markdownTableBodyCenter">for 2 Mbps    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___datarate.html#gga82745de4aa1251b7561564b3ed1d6522ad6a241689903e120c99b6963cb98c97c">RF24_250KBPS</a> (2)   </td><td class="markdownTableBodyCenter">for 250 kbs   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change was successful </dd></dl>

</div>
</div>
<a id="ab6a711a9cc14fb459a4a1698b8665d82" name="ab6a711a9cc14fb459a4a1698b8665d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a711a9cc14fb459a4a1698b8665d82">&#9670;&nbsp;</a></span>setPALevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPALevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lnaEnable</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set Power Amplifier (PA) level and Low Noise Amplifier (LNA) state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The desired <a class="el" href="group___p_a_level.html">Power Amplifier level</a> as defined by <a class="el" href="group___p_a_level.html#ga1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a>. </td></tr>
    <tr><td class="paramname">lnaEnable</td><td>Enable or Disable the LNA (Low Noise Amplifier) Gain. See table for Si24R1 modules below.<br  />
 <code>lnaEnable</code> only affects nRF24L01 modules with an LNA chip.</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>level</code> (enum value)   </th><th class="markdownTableHeadCenter">nRF24L01<br  />
description   </th><th class="markdownTableHeadCenter">Si24R1<br  />
description when<br  />
 <code>lnaEnable</code> = 1   </th><th class="markdownTableHeadCenter">Si24R1<br  />
description when<br  />
 <code>lnaEnable</code> = 0    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___p_a_level.html#gga1e4cd0bea93e6b43422855fb0120aacea445515b775236bb9db3cb4b0b828adff">RF24_PA_MIN</a> (0)   </td><td class="markdownTableBodyCenter">-18 dBm   </td><td class="markdownTableBodyCenter">-6 dBm   </td><td class="markdownTableBodyCenter">-12 dBm    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group___p_a_level.html#gga1e4cd0bea93e6b43422855fb0120aacea7d8d09f4a047b7c22655e56c98ca010c">RF24_PA_LOW</a> (1)   </td><td class="markdownTableBodyCenter">-12 dBm   </td><td class="markdownTableBodyCenter">-0 dBm   </td><td class="markdownTableBodyCenter">-4 dBm    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group___p_a_level.html#gga1e4cd0bea93e6b43422855fb0120aaceaf00c265e162bfbef00cd5366b2796533">RF24_PA_HIGH</a> (2)   </td><td class="markdownTableBodyCenter">-6 dBm   </td><td class="markdownTableBodyCenter">3 dBm   </td><td class="markdownTableBodyCenter">1 dBm    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group___p_a_level.html#gga1e4cd0bea93e6b43422855fb0120aaceab0bfc94c4095e9495b2e49530b623d0d">RF24_PA_MAX</a> (3)   </td><td class="markdownTableBodyCenter">0 dBm   </td><td class="markdownTableBodyCenter">7 dBm   </td><td class="markdownTableBodyCenter">4 dBm   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_r_f24.html#af7c4dcd84466168c5816382ceb366067">getPALevel()</a> function does not care what was passed <code>lnaEnable</code> parameter. </dd></dl>

</div>
</div>
<a id="a343e5d23477181011dea030fafb1954f" name="a343e5d23477181011dea030fafb1954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343e5d23477181011dea030fafb1954f">&#9670;&nbsp;</a></span>setPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set Static Payload Size</p>
<p >This implementation uses a pre-stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>In the python wrapper, this function is the setter of the <code>payloadSize</code> attribute.<br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">radio.payloadSize = 16  <span class="comment"># set the static payload size to 16 bytes</span></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6d3959c8320e64568395f4ef507aef" name="a4c6d3959c8320e64568395f4ef507aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6d3959c8320e64568395f4ef507aef">&#9670;&nbsp;</a></span>setRetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setRetries </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the number of retry attempts and delay between retry attempts when transmitting a payload. The radio is waiting for an acknowledgement (ACK) packet during the delay between retry attempts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>How long to wait between each retry, in multiples of 250 us. The minumum of 0 means 250 us, and the maximum of 15 means 4000 us. The default value of 5 means 1500us (5 * 250 + 250). </td></tr>
    <tr><td class="paramname">count</td><td>How many retries before giving up. The default/maximum is 15. Use 0 to disable the auto-retry feature all together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Disable the auto-retry feature on a transmitter still uses the auto-ack feature (if enabled), except it will not retry to transmit if the payload was not acknowledged on the first attempt. </dd></dl>

</div>
</div>
<a id="ac43ad43c34337ec0de189105bab2213b" name="ac43ad43c34337ec0de189105bab2213b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43ad43c34337ec0de189105bab2213b">&#9670;&nbsp;</a></span>startConstCarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startConstCarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_a_level.html#ga1e4cd0bea93e6b43422855fb0120aace">rf24_pa_dbm_e</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Transmission of constant carrier wave with defined frequency and output power</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Output power to use </td></tr>
    <tr><td class="paramname">channel</td><td>The channel to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If <a class="el" href="class_r_f24.html#a62846750b82682beb7593719eb60ed60">isPVariant()</a> returns true, then this function takes extra measures that alter some settings. These settings alterations include:<ul>
<li><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> to false (for all pipes)</li>
<li><a class="el" href="class_r_f24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries()</a> to retry <code>0</code> times with a delay of 250 microseconds</li>
<li>set the TX address to 5 bytes of <code>0xFF</code></li>
<li><a class="el" href="class_r_f24.html#adb7915b1d2661a82137573344f659e81">flush_tx()</a></li>
<li>load a 32 byte payload of <code>0xFF</code> into the TX FIFO's top level</li>
<li><a class="el" href="class_r_f24.html#a5eacd9ecfbc19864801d714c292cf8be">disableCRC()</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acd19843064cb70ec23507412e519e4ef" name="acd19843064cb70ec23507412e519e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd19843064cb70ec23507412e519e4ef">&#9670;&nbsp;</a></span>startFastWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startFastWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startTx</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Non-blocking write to the open writing pipe used for buffered writes</p>
<dl class="section note"><dt>Note</dt><dd>Optimization: This function now leaves the CE pin high, so the radio will remain in TX or STANDBY-II Mode until a <a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> command is issued. Can be used as an alternative to <a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite()</a> if writing multiple payloads at once. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode with FIFO full for more than 4ms at a time. If the auto retransmit/autoAck is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#adbf25b53d28d1fcc385fd9738a531b75">startWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<p>For single noAck writes: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK response (false), or no ACK response (true). Be sure to have called <a class="el" href="class_r_f24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> at least once before setting this parameter. </td></tr>
    <tr><td class="paramname">startTx</td><td>If this is set to <code>true</code>, then this function sets the nRF24L01's CE pin to active (enabling TX transmissions). <code>false</code> has no effect on the nRF24L01's CE pin and simply loads the payload into the TX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.startFastWrite(buffer, <span class="keyword">False</span>, <span class="keyword">True</span>)  <span class="comment"># 3rd parameter is optional</span></div>
<div class="line"><span class="comment">#     False means expecting ACK response (multicast parameter)</span></div>
<div class="line"><span class="comment">#     True means initiate transmission (startTx parameter)</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30a2733a3889bdc331fe2d2f4f0f7b39" name="a30a2733a3889bdc331fe2d2f4f0f7b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2733a3889bdc331fe2d2f4f0f7b39">&#9670;&nbsp;</a></span>startListening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start listening on the pipes opened for reading.</p>
<ol type="1">
<li>Be sure to call <a class="el" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a> first.</li>
<li>Do not call <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> while in this mode, without first calling <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a>.</li>
<li>Call <a class="el" href="class_r_f24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> to check for incoming traffic, and <a class="el" href="class_r_f24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to get it.</li>
</ol>
<p >Open reading pipe 1 using address <code>0xCCCECCCECC</code> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> address[] = {0xCC, 0xCE, 0xCC, 0xCE, 0xCC};</div>
<div class="line">radio.openReadingPipe(1,address);</div>
<div class="line">radio.startListening();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If there was a call to <a class="el" href="class_r_f24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a> about pipe 0 prior to calling this function, then this function will re-write the address that was last set to reading pipe 0. This is because <a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> will overwrite the address to reading pipe 0 for proper auto-ack functionality. </dd></dl>

</div>
</div>
<a id="adbf25b53d28d1fcc385fd9738a531b75" name="adbf25b53d28d1fcc385fd9738a531b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf25b53d28d1fcc385fd9738a531b75">&#9670;&nbsp;</a></span>startWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::startWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Non-blocking write to the open writing pipe</p>
<p >Just like <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>, but it returns immediately. To find out what happened to the send, catch the IRQ and then call <a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#acd19843064cb70ec23507412e519e4ef">startFastWrite()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a></dd></dl>
<p>For single noAck writes see: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK response (false), or no ACK response (true). Be sure to have called <a class="el" href="class_r_f24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> at least once before setting this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if payload was written to the TX FIFO buffers and the transmission was started.</li>
<li><code>false</code> if the TX FIFO is full and the payload could not be written. In this condition, the transmission process is restarted. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.startWrite(buffer, <span class="keyword">False</span>)  <span class="comment"># False = the multicast parameter</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a38fa92d612b7b9b8a739a68ed7d88330" name="a38fa92d612b7b9b8a739a68ed7d88330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fa92d612b7b9b8a739a68ed7d88330">&#9670;&nbsp;</a></span>stopConstCarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::stopConstCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stop transmission of constant wave and reset PLL and CONT registers</p>
<dl class="section warning"><dt>Warning</dt><dd>this function will <a class="el" href="class_r_f24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a> the radio per recommendation of datasheet. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="class_r_f24.html#a62846750b82682beb7593719eb60ed60">isPVariant()</a> returns true, please remember to re-configure the radio's settings <div class="fragment"><div class="line"><span class="comment">// re-establish default settings</span></div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength</a>(<a class="code hl_enumvalue" href="group___c_r_c_length.html#ggadbe00719f3f835c82bd007081d040a7ea6eeb0379e23be63559106d96ada47a56">RF24_CRC_16</a>);</div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck</a>(<span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="class_r_f24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries</a>(5, 15);</div>
<div class="ttc" id="aclass_r_f24_html_a4c6d3959c8320e64568395f4ef507aef"><div class="ttname"><a href="class_r_f24.html#a4c6d3959c8320e64568395f4ef507aef">RF24::setRetries</a></div><div class="ttdeci">void setRetries(uint8_t delay, uint8_t count)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1782</div></div>
<div class="ttc" id="aclass_r_f24_html_a89f626fc4a58dd997153bcc0f8198b9e"><div class="ttname"><a href="class_r_f24.html#a89f626fc4a58dd997153bcc0f8198b9e">RF24::setCRCLength</a></div><div class="ttdeci">void setCRCLength(rf24_crclength_e length)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1738</div></div>
<div class="ttc" id="aclass_r_f24_html_aec71746d59da978bcbb975167886a2cc"><div class="ttname"><a href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">RF24::setAutoAck</a></div><div class="ttdeci">void setAutoAck(bool enable)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1592</div></div>
<div class="ttc" id="agroup___c_r_c_length_html_ggadbe00719f3f835c82bd007081d040a7ea6eeb0379e23be63559106d96ada47a56"><div class="ttname"><a href="group___c_r_c_length.html#ggadbe00719f3f835c82bd007081d040a7ea6eeb0379e23be63559106d96ada47a56">RF24_CRC_16</a></div><div class="ttdeci">@ RF24_CRC_16</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.h:103</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#ac43ad43c34337ec0de189105bab2213b">startConstCarrier()</a> </dd></dl>

</div>
</div>
<a id="a6f144d73fc447c8ac2d1a4166210fd88" name="a6f144d73fc447c8ac2d1a4166210fd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f144d73fc447c8ac2d1a4166210fd88">&#9670;&nbsp;</a></span>stopListening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::stopListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stop listening for incoming messages, and switch to transmit mode.</p>
<p >Do this before calling <a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. </p><div class="fragment"><div class="line">radio.stopListening();</div>
<div class="line">radio.write(&amp;data, <span class="keyword">sizeof</span>(data));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>When the ACK payloads feature is enabled, the TX FIFO buffers are flushed when calling this function. This is meant to discard any ACK payloads that were not appended to acknowledgment packets. </dd></dl>

</div>
</div>
<a id="ad0d522ccf39493510e64bf1740be790d" name="ad0d522ccf39493510e64bf1740be790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d522ccf39493510e64bf1740be790d">&#9670;&nbsp;</a></span>testCarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test whether there was a carrier on the line for the previous listening period.</p>
<p >Useful to check for interference on the current channel.</p>
<dl class="section return"><dt>Returns</dt><dd>true if was carrier, false if not </dd></dl>

</div>
</div>
<a id="a821285f3b54553f4402eb3fd0ac6d6c1" name="a821285f3b54553f4402eb3fd0ac6d6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821285f3b54553f4402eb3fd0ac6d6c1">&#9670;&nbsp;</a></span>testRPD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testRPD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. Valid only on nRF24L01P (+) hardware. On nRF24L01, use <a class="el" href="class_r_f24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier()</a>.</p>
<p >Useful to check for interference on the current channel and channel hopping strategies.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> goodSignal = radio.testRPD();</div>
<div class="line"><span class="keywordflow">if</span>(radio.available()){</div>
<div class="line">   Serial.println(goodSignal ? <span class="stringliteral">&quot;Strong signal &gt; 64dBm&quot;</span> : <span class="stringliteral">&quot;Weak signal &lt; 64dBm&quot;</span> );</div>
<div class="line">   radio.read(0,0);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>true if a signal less than or equal to -64dBm was detected, false if not. </dd></dl>

</div>
</div>
<a id="a12cc453453c94969d4d3f0edb3778c83" name="a12cc453453c94969d4d3f0edb3778c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cc453453c94969d4d3f0edb3778c83">&#9670;&nbsp;</a></span>txStandBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function should be called as soon as transmission is finished to drop the radio back to STANDBY-I mode. If not issued, the radio will remain in STANDBY-II mode which, per the data sheet, is not a recommended operating mode.</p>
<dl class="section note"><dt>Note</dt><dd>When transmitting data in rapid succession, it is still recommended by the manufacturer to drop the radio out of TX or STANDBY-II mode if there is time enough between sends for the FIFOs to empty. This is not required if auto-ack is enabled.</dd></dl>
<p>Relies on built-in auto retry functionality.</p>
<p >Example (Partial blocking): </p><div class="fragment"><div class="line">radio.writeFast(&amp;buf,32);</div>
<div class="line">radio.writeFast(&amp;buf,32);</div>
<div class="line">radio.writeFast(&amp;buf,32);  <span class="comment">//Fills the FIFO buffers up</span></div>
<div class="line"><span class="keywordtype">bool</span> ok = <a class="code hl_function" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();     <span class="comment">//Returns 0 if failed. 1 if success.</span></div>
<div class="line">                              <span class="comment">//Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div>
<div class="ttc" id="aclass_r_f24_html_a12cc453453c94969d4d3f0edb3778c83"><div class="ttname"><a href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">RF24::txStandBy</a></div><div class="ttdeci">bool txStandBy()</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1229</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>txStandBy(unsigned long timeout) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if all payloads in the TX FIFO were delivered successfully and an acknowledgement (ACK packet) was received for each. If auto-ack is disabled, then any attempt to transmit will also return true (even if the payload was not received).</li>
<li><code>false</code> if a payload was sent but was not acknowledged with an ACK packet. This condition can only be reported if the auto-ack feature is on. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab7f54decbe9d06cb026a5d3dfb505116" name="ab7f54decbe9d06cb026a5d3dfb505116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f54decbe9d06cb026a5d3dfb505116">&#9670;&nbsp;</a></span>txStandBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startTx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function allows extended blocking and auto-retries per a user defined timeout</p>
<p >Fully Blocking Example: </p><div class="fragment"><div class="line">radio.writeFast(&amp;buf,32);</div>
<div class="line">radio.writeFast(&amp;buf,32);</div>
<div class="line">radio.writeFast(&amp;buf,32);   <span class="comment">//Fills the FIFO buffers up</span></div>
<div class="line"><span class="keywordtype">bool</span> ok = <a class="code hl_function" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);  <span class="comment">//Returns 0 if failed after 1 second of retries. 1 if success.</span></div>
<div class="line">                           <span class="comment">//Blocks only until user defined timeout or success. Data flushed on fail.</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Number of milliseconds to retry failed payloads </td></tr>
    <tr><td class="paramname">startTx</td><td>If this is set to <code>true</code>, then this function puts the nRF24L01 in TX Mode. <code>false</code> leaves the primary mode (TX or RX) as it is, which can prevent the mandatory wait time to change modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if all payloads in the TX FIFO were delivered successfully and an acknowledgement (ACK packet) was received for each. If auto-ack is disabled, then any attempt to transmit will also return true (even if the payload was not received).</li>
<li><code>false</code> if a payload was sent but was not acknowledged with an ACK packet. This condition can only be reported if the auto-ack feature is on. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afb97dc4bdf4d2d84ea44060ac5b4ed89" name="afb97dc4bdf4d2d84ea44060ac5b4ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb97dc4bdf4d2d84ea44060ac5b4ed89">&#9670;&nbsp;</a></span>whatHappened()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::whatHappened </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Call this when you get an Interrupt Request (IRQ) to find out why</p>
<p >This function describes what event triggered the IRQ pin to go active LOW and clears the status of all events.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#abf68b9b0c9cd17179e9e144c3e7f9c45">maskIRQ()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_ok</td><td>The transmission attempt completed (TX_DS). This does not imply that the transmitted data was received by another radio, rather this only reports if the attempt to send was completed. This will always be <code>true</code> when the auto-ack feature is disabled. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_fail</td><td>The transmission failed to be acknowledged, meaning too many retries (MAX_RT) were made while expecting an ACK packet. This event is only triggered when auto-ack feature is enabled. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_ready</td><td>There is a newly received payload (RX_DR) saved to RX FIFO buffers. Remember that the RX FIFO can only hold up to 3 payloads. Once the RX FIFO is full, all further received transmissions are rejected until there is space to save new data in the RX FIFO buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function expects no parameters in the python wrapper. Instead, this function returns a 3 item tuple describing the IRQ events' status.<br  />
 To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let`radio` be the instantiated RF24 object</span></div>
<div class="line">tx_ds, tx_df, rx_dr = radio.whatHappened()  <span class="comment"># get IRQ status flags</span></div>
<div class="line">print(<span class="stringliteral">&quot;tx_ds: {}, tx_df: {}, rx_dr: {}&quot;</span>.format(tx_ds, tx_df, rx_dr))</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4cd4c198a47704db20b6b5cf0731cd58" name="a4cd4c198a47704db20b6b5cf0731cd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4c198a47704db20b6b5cf0731cd58">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Be sure to call <a class="el" href="class_r_f24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> first to set the destination of where to write to.</p>
<p >This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60-70ms.</p>
<p >The maximum size of data written is the fixed payload size, see <a class="el" href="class_r_f24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a>. However, you can write less, and the remainder will just be filled with zeroes.</p>
<p >TX/RX/RT interrupt flags will be cleared every time write is called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">radio.stopListening();</div>
<div class="line">radio.write(&amp;data,<span class="keyword">sizeof</span>(data));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.write(buffer)</div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload was delivered successfully and an acknowledgement (ACK packet) was received. If auto-ack is disabled, then any attempt to transmit will also return true (even if the payload was not received).</li>
<li><code>false</code> if the payload was sent but was not acknowledged with an ACK packet. This condition can only be reported if the auto-ack feature is on. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a23bfe6502d74bb5bbccb3a7f2ba2b5ea" name="a23bfe6502d74bb5bbccb3a7f2ba2b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bfe6502d74bb5bbccb3a7f2ba2b5ea">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write for single NOACK writes. Optionally disable acknowledgements/auto-retries for a single payload using the multicast parameter set to true.</p>
<p >Can be used with <a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> to request a response </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK response (false), or no ACK response (true). Be sure to have called <a class="el" href="class_r_f24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> at least once before setting this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload was delivered successfully and an acknowledgement (ACK packet) was received. If auto-ack is disabled, then any attempt to transmit will also return true (even if the payload was not received).</li>
<li><code>false</code> if the payload was sent but was not acknowledged with an ACK packet. This condition can only be reported if the auto-ack feature is on.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.write(buffer, <span class="keyword">False</span>)  <span class="comment"># False = the multicast parameter</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a36b9fc363d3560358fe430a600a6f385" name="a36b9fc363d3560358fe430a600a6f385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b9fc363d3560358fe430a600a6f385">&#9670;&nbsp;</a></span>writeAckPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeAckPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write an acknowledgement (ACK) payload for the specified pipe</p>
<p >The next time a message is received on a specified <em>pipe</em>, the data in <em>buf</em> will be sent back in the ACK payload.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>ACK payloads are handled automatically by the radio chip when a regular payload is received. It is important to discard regular payloads in the TX FIFO (using <a class="el" href="class_r_f24.html#adb7915b1d2661a82137573344f659e81">flush_tx()</a>) before loading the first ACK payload into the TX FIFO. This function can be called before and after calling <a class="el" href="class_r_f24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only three of these can be pending at any time as there are only 3 FIFO buffers.<br  />
 Dynamic payloads must be enabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ACK payloads are dynamic payloads. Calling <a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> will automatically enable dynamic payloads on pipe 0 (required for TX mode when expecting ACK payloads). To use ACK payloads on any other pipe in RX mode, call <a class="el" href="class_r_f24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe# (typically 1-5) will get this response. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data that is sent </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data to send, up to 32 bytes max. Not affected by the static payload set by <a class="el" href="class_r_f24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.writeAckPayload(1, buffer)  <span class="comment"># load an ACK payload for response on pipe 1</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload was loaded into the TX FIFO.</li>
<li><code>false</code> if the payload wasn't loaded into the TX FIFO because it is already full or the ACK payload feature is not enabled using <a class="el" href="class_r_f24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae6fd8d5ee490d54ae1cb2e8fefee535f" name="ae6fd8d5ee490d54ae1cb2e8fefee535f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fd8d5ee490d54ae1cb2e8fefee535f">&#9670;&nbsp;</a></span>writeBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeBlocking </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function extends the auto-retry mechanism to any specified duration. It will not block until the 3 FIFO buffers are filled with data. If so the library will auto retry until a new payload is written or the user specified timeout period is reached. </p><dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<p>Example (Full blocking): </p><div class="fragment"><div class="line">radio.writeBlocking(&amp;buf, <span class="keyword">sizeof</span>(buf), 1000); <span class="comment">// Wait up to 1 second to write 1 payload to the buffers</span></div>
<div class="line">radio.txStandBy(1000);                        <span class="comment">// Wait up to 1 second for the payload to send. Return 1 if ok, 0 if failed.</span></div>
<div class="line">                                              <span class="comment">// Blocks only until user timeout or success. Data flushed on fail.</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">timeout</td><td>User defined timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.writeBlocking(buffer, 1000)  <span class="comment"># 1000 means wait at most 1 second</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload passed to <em>buf</em> was loaded in the TX FIFO.</li>
<li><code>false</code> if the payload passed to <em>buf</em> was not loaded in the TX FIFO because a previous payload already in the TX FIFO failed to transmit. This condition can only be reported if the auto-ack feature is on. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a47b2516993481b58e724d1274a7fd9cb" name="a47b2516993481b58e724d1274a7fd9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b2516993481b58e724d1274a7fd9cb">&#9670;&nbsp;</a></span>writeFast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This will not block until the 3 FIFO buffers are filled with data. Once the FIFOs are full, writeFast will simply wait for success or timeout, and return 1 or 0 respectively. From a user perspective, just keep trying to send the same data. The library will keep auto retrying the current payload using the built in functionality. </p><dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<div class="fragment"><div class="line">Example (Partial blocking):</div>
<div class="line"> </div>
<div class="line">        radio.<a class="code hl_function" href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div>
<div class="line">        <a class="code hl_function" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();               <span class="comment">// Returns 0 if failed. 1 if success. Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div>
<div class="line"> </div>
<div class="line">        radio.writeFast(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div>
<div class="line">        <a class="code hl_function" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);           <span class="comment">// Using extended timeouts, returns 1 if success. Retries failed payloads for 1 seconds before returning 0.</span></div>
<div class="ttc" id="aclass_r_f24_html_a47b2516993481b58e724d1274a7fd9cb"><div class="ttname"><a href="class_r_f24.html#a47b2516993481b58e724d1274a7fd9cb">RF24::writeFast</a></div><div class="ttdeci">bool writeFast(const void *buf, uint8_t len)</div><div class="ttdef"><b>Definition:</b> BimTiController_RF24.cpp:1182</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="class_r_f24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload was delivered successfully and an acknowledgement (ACK packet) was received. If auto-ack is disabled, then any attempt to transmit will also return true (even if the payload was not received).</li>
<li><code>false</code> if the payload was sent but was not acknowledged with an ACK packet. This condition can only be reported if the auto-ack feature is on.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.writeFast(buffer)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad16d53de0327c0b41d170cbda4bf41af" name="ad16d53de0327c0b41d170cbda4bf41af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16d53de0327c0b41d170cbda4bf41af">&#9670;&nbsp;</a></span>writeFast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >WriteFast for single NOACK writes. Optionally disable acknowledgements/auto-retries for a single payload using the multicast parameter set to true.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_f24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK response (false), or no ACK response (true). Be sure to have called <a class="el" href="class_r_f24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> at least once before setting this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> if the payload passed to <em>buf</em> was loaded in the TX FIFO.</li>
<li><code>false</code> if the payload passed to <em>buf</em> was not loaded in the TX FIFO because a previous payload already in the TX FIFO failed to transmit. This condition can only be reported if the auto-ack feature is on.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>len</em> parameter must be omitted when using the python wrapper because the length of the payload is determined automatically. <br  />
To use this function in the python wrapper: <div class="fragment"><div class="line"><span class="comment"># let `radio` be the instantiated RF24 object</span></div>
<div class="line">buffer = b<span class="stringliteral">&quot;Hello World&quot;</span>  <span class="comment"># a `bytes` object</span></div>
<div class="line">radio.writeFast(buffer, <span class="keyword">False</span>)  <span class="comment"># False = the multicast parameter</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad08121bf844f08dbe53f51576b7c4066" name="ad08121bf844f08dbe53f51576b7c4066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08121bf844f08dbe53f51576b7c4066">&#9670;&nbsp;</a></span>csDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24::csDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >On all devices but Linux and ATTiny, a small delay is added to the CSN toggling function</p>
<p >This is intended to minimise the speed of SPI polling due to radio commands</p>
<p >If using interrupts or timed requests, this can be set to 0 Default:5 </p>

</div>
</div>
<a id="a2e40fe66d1231a333aa2534e8491f828" name="a2e40fe66d1231a333aa2534e8491f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e40fe66d1231a333aa2534e8491f828">&#9670;&nbsp;</a></span>failureDetected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::failureDetected</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If a failure has been detected, it usually indicates a hardware issue. By default the library will cease operation when a failure is detected. This should allow advanced users to detect and resolve intermittent hardware issues.</p>
<p >In most cases, the radio must be re-enabled via radio.begin(); and the appropriate settings applied after a failure occurs, if wanting to re-enable the device immediately.</p>
<p >The three main failure modes of the radio include:</p>
<p >Writing to radio: Radio unresponsive - Fixed internally by adding a timeout to the internal write functions in <a class="el" href="class_r_f24.html" title="Driver class for nRF24L01(+) 2.4GHz Wireless Transceiver.">RF24</a> (failure handling)</p>
<p >Reading from radio: Available returns true always - Fixed by adding a timeout to available functions by the user. This is implemented internally in RF24Network.</p>
<p >Radio configuration settings are lost - Fixed by monitoring a value that is different from the default, and re-configuring the radio if this setting reverts to the default.</p>
<p >See the included example, GettingStarted_HandlingFailures</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.failureDetected){</div>
<div class="line">  radio.begin();                       <span class="comment">// Attempt to re-configure the radio with defaults</span></div>
<div class="line">  radio.failureDetected = 0;           <span class="comment">// Reset the detection value</span></div>
<div class="line"> radio.openWritingPipe(addresses[1]); <span class="comment">// Re-configure pipe addresses</span></div>
<div class="line">  radio.openReadingPipe(1,addresses[0]);</div>
<div class="line">  report_failure();                    <span class="comment">// Blink leds, send a message, etc. to indicate failure</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a958fb99f54415101ca008ab11b3bfe79" name="a958fb99f54415101ca008ab11b3bfe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fb99f54415101ca008ab11b3bfe79">&#9670;&nbsp;</a></span>txDelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24::txDelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The driver will delay for this duration when <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> is called</p>
<p >When responding to payloads, faster devices like ARM(RPi) are much faster than Arduino:</p><ol type="1">
<li>Arduino sends data to RPi, switches to RX mode</li>
<li>The RPi receives the data, switches to TX mode and sends before the Arduino radio is in RX mode</li>
<li>If AutoACK is disabled, this can be set as low as 0. If AA/ESB enabled, set to 100uS minimum on RPi</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>If set to 0, ensure 130uS delay after <a class="el" href="class_r_f24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> and before any sends </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/BimTi_NRF24/<a class="el" href="_bim_ti_controller___r_f24_8h_source.html">BimTiController_RF24.h</a></li>
<li>src/BimTi_NRF24/BimTiController_RF24.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
